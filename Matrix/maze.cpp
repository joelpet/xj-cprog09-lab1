#include "matrix.h"         // inkludera din headerfil här

struct Cell {
    int x;
    int y;
    Cell(int row, int col) : x(row), y(col) {}

};

std::ostream & operator<<(std::ostream & out, const Cell & cell) {
    out << "(" << cell.x << ", " << cell.y << ")";
    return out;
}

bool operator==(Cell & a, Cell & b) {
    return ((a.x == b.x) && (a.y == b.y));
}

Matrix * buildMatrix(const char * labyrinth[]);
void pathFinder(Matrix &);
Cell entrance(Matrix &);
Cell exit(Matrix &);
bool solove(Cell, Cell, Matrix &);

int main()
{
    const char *small[] =
    {"#####################",
        "      # # #   # # # #",
        "##### #     # #   # #",
        "#     ##### # # #   #",
        "### # #   # #   # # #",
        "# # # # # # ####### #",
        "#   #   #   #       #",
        "## ############ #####",
        "#   #                ",
        "#####################",
        0};

    const char *medium[] =
    {"# #######################################",
        "# #                   #     #   #     # #",
        "# # ### ############# # # ### # # ### # #",
        "# #   #     #   #   #   #     # #   # # #",
        "# ### # ### # # # # ##### ####### # # # #",
        "#   # # # #   #   #     #   #   # # # # #",
        "### # # # # ########### ##### # ### # # #",
        "#   # #   #   # #             # #   # # #",
        "# # # ####### # # ############# # ### # #",
        "# # #     #   # #             # #   # # #",
        "# ### ### # ### ############# # ### # # #",
        "#   #   # #   #   #     #   # # #   # # #",
        "### ##### ### ### # # ### # # # # ### # #",
        "#   #     # # #     #     # # # # # #   #",
        "# ### ##### # # ############# # # # # ###",
        "#     #     # #               # # # #   #",
        "####### ##### ################### # # ###",
        "#         #   #     #             # #   #",
        "# ####### # ### # # # ############# ### #",
        "#       #       # #               #     #",
        "####################################### #",
        0};

    const char *large[] =
    {"# ###############################################################################",
        "# #         # #     #       #         #       #   #     #     #   #             #",
        "# ### ##### # # ### # ##### # ##### # # ### ### # # ### ##### # # # # ##### #####",
        "#   # #   # # # # #   #     # #   # #   # #   # # # # #     # # #   # #   # #   #",
        "# # # # # # # # # ### # ##### # # # ##### # # # # # # # ### # # ##### # # ### # #",
        "# #   # #     # # #   #     #   # # #   #   #   # # # # # #   #     #   # #   # #",
        "####### ####### # # ### ######### ### ####### ### # # # # # # ##### ##### # ### #",
        "#   #   #     # # # # #         #   #   #     #   # #   #   #   # #     #   #   #",
        "# # # ### ### # # # # # ####### ### ### # # ### ##### ######### # # ### ##### ###",
        "# #   #   # #   #   # # #     #   # #   # #   #     # #   #   #   # # # #   #   #",
        "# ##### ### # ####### # ##### # # # # ### ######### # ### # # ##### # # # # # ###",
        "#     #     #   #     #     # # #   #     #   #   # #   # # #       # # # # #   #",
        "# ##### # ##### # ######### # ####### ##### # ### # # # # # ######### # ### # # #",
        "#   #   # #   #     #     #   #     #     # #   # # # #   #   #       #     # # #",
        "### # ### # ####### # ### ##### ### ##### # ### # # # ######### # ########### # #",
        "#   # # #       # #   #       #   #     # # # #     # #         #   #     #   # #",
        "# ### # ####### # ##### ######### ##### ### # # ##### # ######### # # ##### # # #",
        "# #   #   #     #       #   #     #   #     # # #   # # #     #   # #   #   # # #",
        "# # ##### # ############# ### ### # # ####### # # # # # ### # # ### ### # ##### #",
        "#   #   # #             #   #   # # # #   #   #   # # # #   # #   # #   # #   # #",
        "##### # # ######### ### ### ### ### # # # # ####### # # # ##### # # # ### # # # #",
        "#   # #           #   #   #   #     #   # #   #       # # #     # # #   # # #   #",
        "# ### ########### ### # ### ### ######### # # ######### # # ##### ### # # # #####",
        "# #   #     #   # #   #   #   # #     #   # #   #     # #   # #   #   # # # #   #",
        "# # ### ### # # # # ##### ### # # ### # ####### # # # # ##### # ### # # # # # ###",
        "# # #     #   #   # #   #     # # #   #         # # # #       #   # # # # #     #",
        "# # # ### ########### # # ##### # ######### ##### # ### ######### # ### # ##### #",
        "#   #   # #       #   #   #     #         #       #     #   #     #   # # #     #",
        "####### # # ##### # ##################### ########### ### # # ####### # # # #####",
        "#     # # # #   #   #     #     #   #   # #     #   # #   # # #       # # #     #",
        "# ### # ### # ####### # # # ### ### # # # # # # # # # # ##### # # ####### #######",
        "# # #       # #       # #   #   #   # # #   # # # # # # #     # #   # #   #     #",
        "# # # ####### # ####### ##### ### ### # ##### # # # ### # ### # # # # # ### ### #",
        "#   # #     # #       # #   #   #     #   # # #   #     #   #   # #   #     # # #",
        "##### # ### # ####### ### # # ########### # # # ### ####### ####### ######### # #",
        "#   #     #         #   # # #       #   # # # # # #   #     #     #   #   #   # #",
        "# ### # ########### ### # # ####### # # # # # # # # # # ##### ### ### # # # ### #",
        "# #   # #   #   #     #   #       #   #     # # # # #   #     #   # # # #     # #",
        "# # ##### ### # ########### ############# ### # # ####### ##### ### # ### # # # #",
        "# #     #   # #     #   #   #     #     #   # # #       # #     #   #     # #   #",
        "# ### # ### # ##### # # # ### ### # ### ##### # # ##### # # ##### ######### #####",
        "#   # #   # # #     # #   #   #   #   #       # #     #   #   #   #   #     #   #",
        "### ##### # # ####### # ### ### ##### ########### ### ####### # ### # ####### # #",
        "#     #   # #       # #   # #   #   #           # #   #       #   # #       # # #",
        "### # # ### ####### # ### # # ### # ########### ### ####### ### # # ####### # # #",
        "#   # # #   #   #   #   #   #   # #   #             #     #   # # #   #   # # # #",
        "# ##### # # # # # ##### # ##### ### # ############### ### ##### # ### # # # ### #",
        "#         # # # # #     # #   # #   #         #     #   #       # #   # # #   # #",
        "# ##### ### # # # # ####### # # # ##### ##### # ##### # ######### # ### # ### # #",
        "# #   #   #   # # #     #   # # # #   # # #   #   #   # # #   #   # #   #   #   #",
        "# # # ######### # ##### # ### # # # # # # # # ### # # # # # ### # ### ##### # ###",
        "# # #   #     # #     # #   # #     # #   # #     # # # # #   # #   #     #     #",
        "### # # # ### # ##### # # # ######### ##### ####### # # # ### # ### ########### #",
        "#   # #   #   #   #   # # #         # #   #   # #   # #   # #   #       #   #   #",
        "# ##### ####### # # ### # ######### # # # ### # # ####### # # ### ####### # # ###",
        "# #   # #     # # #   # #   #   # # # # #   #   # #     # # #   #         # #   #",
        "# # # # # ### # ### # # ### # # # # # # # ### ### # ##### # # # ########### ### #",
        "#   # #   # #   #   # # # # # #   #   # # #   #   #     #   # #   #   #   #     #",
        "##### ##### # ### ### # # # # # ####### # # ### ####### ##### ### # # # #########",
        "#           #       #     #   #         # #           #         #   #           #",
        "############################################################################### #",
        0}; 

    // använd matrisklassen för att lösa matriserna ovan!

    std::string row;

    Matrix * a = buildMatrix(small);
    pathFinder(*a);

    getline(std::cin, row);

    a = buildMatrix(medium);
    pathFinder(*a);

    getline(std::cin, row);

    a = buildMatrix(large);
    pathFinder(*a);

    return 0; 
}

Matrix * buildMatrix(const char * labyrinth[]) {
    int row = 0;
    int col = 0;

    for (int i = 0; labyrinth[i] != 0; i++) {
        // std::cout << labyrinth[i] << std::endl;
        if (col == 0) {
            while (labyrinth[i][col] != 0)
                col++;
        }
        row++;
    }
    std::cout << "Matrix size: " << "col: " << col << "\t row: " << row << std::endl;

    Matrix * a = new Matrix(row, col);
    // Matrix a(row, col);

    for (int i = 0; labyrinth[i] != 0; i++) {
        for (int j = 0; labyrinth[i][j] != 0; ++j) {
            if(labyrinth[i][j] == ' ') {
                (*a)[i][j] = 1;
            }
        }
    }
    return a;
}

void pathFinder(Matrix & a) {
    Cell start = entrance(a);
    Cell finish = exit(a);
    std::cout << "Entrance: " << start << std::endl;;

    std::cout << "Exit:     " << finish << std::endl;;

    solove(start, finish, a);

    for (unsigned int i = 0; i < a.num_columns; i++) {
        for (unsigned int j = 0; j < a.num_rows; j++) {
            switch (a[i][j]) {
                case 0:
                    std::cout << '#';
                    break;
                    // case 1:
                    // break;
                case 2:
                    std::cout << 'x';
                    break;
                case 3:
                    std::cout << '.';
                    break;
                default:
                    std::cout << ' ';
                    break;
            }
        }
        std::cout << std::endl;
    }
}

bool solove(Cell start, Cell finish, Matrix & a) {
    if (start == finish) {
        a[start.x][start.y] = 3;
        return true;
    }

    if (start.x >= (int)a.num_columns || start.y >= (int)a.num_rows 
            || start.x < 0 || start.y < 0) 
        return false;

    a[start.x][start.y]++;


    // Check all around our current position
    if (a[start.x][start.y+1] == 1) {
        if (solove(Cell(start.x, start.y+1), finish, a)) {
            a[start.x][start.y]++;
            return true;
        }
    }

    if (a[start.x][start.y-1] == 1) {
        if (solove(Cell(start.x, start.y-1), finish, a)) {
            a[start.x][start.y]++;
            return true;
        }
    }

    if (a[start.x+1][start.y] == 1) {
        if (solove(Cell(start.x+1, start.y), finish, a)) {
            a[start.x][start.y]++;
            return true;
        }
    }

    if (a[start.x-1][start.y] == 1) {
        if (solove(Cell(start.x-1, start.y), finish, a)) {
            a[start.x][start.y]++;
            return true;
        }
    }


    return false;
}

Cell entrance(Matrix & a) {
    for (unsigned int i = 0; i < a.num_columns; i++) {
        if (a[i][0] == 1) {
            return Cell(i,0);
        }
    }
    for (unsigned int i = 0; i < a.num_rows; i++) {
        if (a[0][i] == 1) {
            return Cell(0,i);
        }
    }
    return Cell(-1,-1);
}

Cell exit(Matrix & a) {
    for (unsigned int i = 0; i < a.num_columns; i++) {
        if (a[i][a.num_rows-1] == 1) {
            return Cell(i,a.num_rows-1);
        }
    }
    for (unsigned int i = 0; i < a.num_rows; i++) {
        if (a[a.num_columns-1][i] == 1) {
            return Cell(a.num_columns-1,i);
        }
    }
    return Cell(-1,-1);
}
